<!DOCTYPE html>
<html lang="en">
  
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
    rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/reset.css" />
  <link rel="stylesheet" href="../css/index.css" />
  <link rel="stylesheet" href="../css/blog.css" />
  <title>NodeSecure - Blog</title>
</head>

<body>
  <canvas id="network-bg"></canvas>

  <header class="blogHeader">
    <div class="header-background"></div>
    <div class="header-content centered-content">
      <img src="https://avatars.githubusercontent.com/u/85318671?s=200&v=4" alt="NodeSecure Logo"
        style="width:80px;height:80px;border-radius:20px;background:#fff2;box-shadow:0 2px 8px #0002;margin-bottom:1.2rem;">
      <h1>
        NodeSecure Blog
      </h1>
      <p class="subtitle">
        Building a safer Node.js and JavaScript ecosystem
      </p>
      <p class="description">We are a community of developers building free open source tools to secure the Node.js & JavaScript ecosystem. Our area of expertise is <b>SCA</b> (Software Composition Analysis).</p>
      <div class="header-buttons">
        <a href="https://github.com/NodeSecure" target="_blank" title="NodeSecure on GitHub" class="view-on-github">
          <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/github.svg" alt="GitHub"
            style="width:28px;height:28px;filter:invert(1) brightness(2);">
          <span>View on GitHub</span>
        </a>
        <a href="https://discord.gg/4Wn8rjAtB4" target="_blank" title="Join our Discord" class="view-on-discord">
          <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/discord.svg" alt="Discord"
            style="width:28px;height:28px;filter:invert(1) brightness(2);">
          <span>Join Discord</span>
        </a>
        <a href="./index.html" title="Visit our blog" class="view-on-discord">
          <img width="64" height="64" src="https://img.icons8.com/glyph-neue/64/circled-left-2.png"   style="width:28px;height:28px;filter:invert(1) brightness(2);" alt="Back to blog"/>
          <span>Back to blog</span>
        </a>
      </div>
    </div>
  </header>
  <main>
    
    <article>
      <div class="article-content">
        <h1 class="article-title">A technical tale of NodeSecure - Chapter 1</h1>
        <p>Hello üëã</p>
<p>I have been working on the <a href="https://github.com/NodeSecure">NodeSecure</a> project for almost three years now üòµ. I have personally come a long way... At the beginning I didn't know much about the field in which I started üê§.</p>
<p>That's why I thought that writing articles about <em>"some"</em> of the technical difficulties and the tools I used could be valuable üöÄ.</p>
<p>I will try to make articles that focus on one aspect üéØ. Let's get started üíÉ.</p>
<h2>üîç Fetching the dependency tree</h2>
<p>One of the first challenges I had to solve was how to get the dependency tree and all the information attached to the packages.</p>
<p>My first instinct was to work with <a href="https://github.com/npm/registry/blob/master/docs/REGISTRY-API.md">the public API of the npm registry</a>.
This sounds like a very good idea, but you will soon run into a set of problems (cache, private registry etc..).</p>
<p>What I wanted to do has already been implemented in the package named <a href="https://github.com/npm/pacote#readme">pacote</a>.</p>
<blockquote>
<p><strong>Note:</strong> <a href="https://github.com/npm/arborist#readme">Arborist</a> did not exist yet. I will come back to this in a future article. The first versions of NodeSecure did not support the analysis of a local project anyway.</p>
</blockquote>
<h3>Pacote</h3>
<p>As its README suggests, Pacote is a library that allows you to retrieve various data for a given package. To be more precise:</p>
<ul>
<li><strong>A package manifest</strong> (<em>A manifest is similar to a package.json file. However, it has a few pieces of extra metadata, and sometimes lacks metadata that is inessential to package installation.</em>)</li>
<li><strong>A packument</strong> (<em>A packument is the top-level package document that lists the set of manifests for available versions for a package.</em>)</li>
<li><strong>A tarball</strong> (<em>The archive containing the package itself with the published files</em>)</li>
</ul>
<p>These terms are really important and are explained in the pacote README.</p>
<blockquote>
<p><strong>Note:</strong> There is a package with the type definitions <a href="https://github.com/npm/types">@npm/types</a>.</p>
</blockquote>
<p>In the <a href="https://github.com/NodeSecure/scanner">NodeSecure/scanner</a> these methods are used at different stages of the analysis. When we browse the dependency tree for example we use the <code>manifest()</code> method with the range version (or <strong>specifier</strong>) of the package.</p>
<pre><code class="language-js">await pacote.manifest(gitURL ?? packageName, {
  ...NPM_TOKEN,
  registry: getLocalRegistryURL(),
  cache: `${os.homedir()}/.npm`
});
</code></pre>
<p>The library allows you to manage a whole set of things quite quickly without too much difficulty üí™.</p>
<p>Note that in the above code <strong>there is a notion of Git URL</strong> üëÄ.</p>
<h3>üî¨ Dependency resolution</h3>
<p>You are probably used to see <a href="https://semver.org/lang/fr/">SemVer</a> versions or ranges within your package.json. Quite similar to this:</p>
<pre><code class="language-json">"dependencies": {
    "@nodesecure/flags": "^2.2.0",
    "@nodesecure/fs-walk": "^1.0.0",
    "@nodesecure/i18n": "^1.2.0",
    "@nodesecure/js-x-ray": "^4.1.2",
    "@nodesecure/npm-registry-sdk": "^1.3.0"
}
</code></pre>
<p>But there are many other ways to install/link a dependency within a package.json üò≤:</p>
<ul>
<li><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#urls-as-dependencies">URL to a tarball archive</a></li>
<li><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#git-urls-as-dependencies">Git URLs</a></li>
<li><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#github-urls">GitHub URLs</a></li>
<li><a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#local-paths">Local Paths</a></li>
</ul>
<p>One of the advantages of pacote is that it handles most of these resolutions for you üòé. I discovered all this while working on the subject (because I had never dealt with those types of resolutions).</p>
<p>If you want to be able to spot them here is a regular expression:</p>
<pre><code class="language-js">if (/^([a-zA-Z]+:|git\+|\.\\)/.test(version)) {
  // Version with custom resolution
}
</code></pre>
<p>This also explains why in NodeSecure we have a "<a href="https://github.com/NodeSecure/flags/blob/main/FLAGS.md">hasCustomResolver</a>" flag allowing quick identification of packages using resolutions to dependencies that diverge from the usual.</p>
<p>Pacote also exposes a <code>resolve()</code> method:</p>
<pre><code class="language-js">import pacote from "pacote";

const tarURL = await pacote.resolve("@slimio/is@^1.0.0");
</code></pre>
<p>It resolve a specifier like <code>foo@latest</code> or <code>github:user/project</code> all the way to a tarball url, tarball file, or git repo with commit hash.</p>
<h3>üì¶ Download and extract tarball</h3>
<p><a href="https://github.com/NodeSecure/scanner/blob/master/src/tarball.js#L49">One of the steps</a> is to retrieve the package on the local system to be able to analyze it and retrieve a set of information.</p>
<pre><code class="language-js">const spec = ref.flags.includes("isGit") ?
  ref.gitUrl : `${name}@${version}`;

await pacote.extract(spec, dest, {
  ...NPM_TOKEN,
  registry: getLocalRegistryURL(),
  cache: `${os.homedir()}/.npm`
});
</code></pre>
<p>The package will be extracted into a temporary directory generated when the scanner is launched.</p>
<blockquote>
<p><strong>Note:</strong> see <a href="https://nodejs.org/api/fs.html#fspromisesmkdtempprefix-options">fs.mkdtemp</a></p>
</blockquote>
<p>Once the extraction is finished, we will retrieve the information we need:</p>
<ul>
<li>Files, extensions, size on disk etc..</li>
<li>Execute <a href="https://github.com/NodeSecure/js-x-ray">NodeSecure/JS-X-Ray</a> on each JavaScript files.</li>
<li>Fetch licenses and retrieve their SPDX conformance.</li>
</ul>
<p>We will dig deeper into the steps of static code analysis in a future article.</p>
<h3>üòà It can't be that simple</h3>
<p>In all this there are things quite complex to manage:</p>
<ul>
<li>Same packages but with different "range" of versions üé≠.</li>
<li>Ensure the integrity of the links (relations) between packages.</li>
</ul>
<hr>
<p><strong>The first one</strong> is hard because most of the time we are dealing with SemVer range and not with the EXACT version of the package. There is quite a bit of connection here with how npm handles conflict during installation (also <a href="https://github.com/npm/npm-pick-manifest">how npm algorithms pick the right manifest</a>).</p>
<p>I think I probably still lack some vision and experience on the subject. The current code is probably quite heavy too.</p>
<p>Today the <code>cwd</code> API of the Scanner use Arborist. For the <code>from</code> API i would like to avoid having to deal with a packument.</p>
<hr>
<p>For <strong>the second one</strong> it is mainly a problem with the behaviour of the walker that will browse asynchronously the tree. We must therefore avoid that a package already analyzed is taken into account again. The problem with this is that we will be missing relationship links between some packages in the tree.</p>
<p>The current scanner solves the problem by going through all the dependencies one last time to create the missing link.</p>
<pre><code class="language-js">for (const [packageName, descriptor] of payload.dependencies) {
  for (const verStr of descriptor.versions) {
    const verDescriptor = descriptor[verStr];

    const fullName = `${packageName}@${verStr}`;
    const usedDeps = exclude.get(fullName) ?? new Set();
    if (usedDeps.size === 0) {
      continue;
    }

    const usedBy = Object.create(null);
    const deps = [...usedDeps].map((name) =&gt; name.split(" "));
    for (const [name, version] of deps) {
      usedBy[name] = version;
    }
    Object.assign(verDescriptor.usedBy, usedBy);
  }
}
</code></pre>
<h2>‚ú® Conclusion</h2>
<p>That's it for this article where we have explored a little bit the difficulties around going through the dependency tree.</p>
<p>If you like the concept don't hesitate to like and share.</p>
<p>üôè Thanks for reading and see you soon for a new article.</p>

      </div>
    </article>
  </main>

  <script type="module" src="../src/particules.js"></script>
</body>

</html>